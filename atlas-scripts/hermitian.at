<basic.at
<ext_deform.at { for full_deform@(Parma,mat), only used in |c_form_std_hold| }
<thetastable.at {for dim_u_cap_p}

{         c_form on standard representations, correct in all cases   }

{ c_form_std:
  write c-invariant form on standard module in terms of standardrepks,
  as a ParamPol
}
set c_form_std (Param p) = ParamPol:
  let G=real_form(p) in
  if (is_equal_rank(G))
  then full_deform(p) {built-in is faster in equal rank case}
  else full_deform(p,G.distinguished_involution)
  fi

set c_form_std(Param p, mat delta)=full_deform(p,delta)

{    c_form on irreducible representations   }

{ this is the correct formula for the c-form on G in all cases
  if G is not equal rank we also need the c-form on the extended group
  in order to compute the Hermitian form on G, or equivalently
  c_form_irreducible_twisted (formerly known as c_form_irreducible_delta)
}
set c_form_irreducible (Param p) = ParamPol:
( let ori_nr_p = orientation_nr(p), P = null_module(real_form(p)) in
  for ev@q in KL_sum_at_s(p)
  do P +:= ev*orientation_nr_term(ori_nr_p,q)*full_deform(q) od
; P
)

{ c_form_irreducible_long(y) returns a ParamPol of standardrepks
  giving the c-invariant form on irreducible(y)
  formula used: when
    J(y)  =sum_x               (-1)^{ell(x)-ell(y)}P(x,y)(q=1)I(x)
  then
    J(y)_c=sum_x (-1)^{on(x,y)}(-1)^{ell(x)-ell(y)}P(x,y)(q=s)I(x)_c
  where
    P(x,y) is a cumulated KL polynomial
    (-1)^{ell(x)-ell(y)}P(x,y) is given by signed_KL_col(y)[i] with
    indices[i]=x on(x,y)=orientation number given by orientation_nr_term()
    I(x)_c given as combination of standards x' with nu(x')=0 by c_form_std(x)
  algorithm: compute the sum for J(y)_c, using signed_KL_col and c_form_std
}
set c_form_irreducible_long (Param p) = (ParamPol,[(Param,Split,ParamPol)]):
( let P = null_module(real_form(p)), ori_nr_p = orientation_nr(p)
  then standards =
    for ev@q in KL_sum_at_s(p)
    do
      let form_on_standard = c_form_std(q)
      ,   factor           = ev*orientation_nr_term(ori_nr_p,q)
      in P +:= factor*form_on_standard
    ; (q,factor,form_on_standard)
    od
  in (P,standards)
)

{    c_form_irreducible_twisted and its variants   }

{ The following function implements algorithm from Vogan in email 9/22/16:
  with change: start with twisted polynomial, not ordinary
  * for each term delta-fixed term q add full_deform(q,delta),
  * for each pair {q,delta(q)} add q*0.
  For second kind it it convenient to add q*0 and delta(q)*0 separately
  and at the end divide the sum of such contributions by 2.
  It is not clear at the moment what the mathematical meaning of the expression
  is, so I'm calling it |c_form_irreducible_delta| for now. It is what is
  needed to compute the Hermitian form on an irreducible (multiply each term
  in this sum by 1 or s; which of the two is to be determined later)
}

set c_form_irr_as_sum_of_standards(Param p, mat delta)=ParamPol:
( let G=p.real_form then
  ori_nr_p = orientation_nr(p) then
  rv=null_module(G) then
  Ptw=twisted_KL_sum_at_s(p) then
  P=KL_sum_at_s(p) in
  for ev@q in P
  do
    if is_fixed(delta,q) then
     let new_ev=divide_by((P[q]+Ptw[q])+s*(P[q]-Ptw[q]),2)  then
         c=new_ev*orientation_nr_term(ori_nr_p,q) in rv +:= c*q
    else
         let c=ev*orientation_nr_term(ori_nr_p,q) in rv +:= c*q
    fi
  od
; rv
)

{ basic version of c_form_irreducible_twisted, for any delta }
set c_form_irreducible_twisted(Param p,mat delta) = ParamPol:
( let G=p.real_form then
  ori_nr_p = orientation_nr(p) then
  fixed_terms = null_module(G), unfixed_terms = null_module(G) then
  Ptw=twisted_KL_sum_at_s(p) then
  P=KL_sum_at_s(p) in
  for ev@q in P
  do
    if is_fixed(delta,q) then
     let new_ev=divide_by((P[q]+Ptw[q])+s*(P[q]-Ptw[q]),2)  then
         c=new_ev*orientation_nr_term(ori_nr_p,q) in fixed_terms +:= c*full_deform(q,delta)
    else
         let c=ev*orientation_nr_term(ori_nr_p,q) in unfixed_terms +:= c*one_plus_s*(q*0)
    fi
  od
; fixed_terms + divide_by(2,unfixed_terms)
)

{if delta isn't given assume it is the default}
set c_form_irreducible_twisted (Param p) = ParamPol:c_form_irreducible_twisted(p,real_form(p).distinguished_involution)

{included for backward compatibility:}
set c_form_irreducible_delta (Param p) = ParamPol:c_form_irreducible_twisted(p)

{more information about c_form_irreducible_delta}
set c_form_irreducible_twisted_long (Param p,mat delta) =(ParamPol,[(string,Split,Param,ParamPol)],ParamPol):
( let G=p.real_form then
  ori_nr_p = orientation_nr(p) then
  fixed_terms = null_module(G), unfixed_terms = null_module(G) then
  terms=[] then
  Ptw=twisted_KL_sum_at_s(p) then
  P=KL_sum_at_s(p) then
  character_formula=P.s_to_1 in
  for ev@q in P
  do
    (if is_fixed(delta,q) then
     let new_ev=divide_by((P[q]+Ptw[q])+s*(P[q]-Ptw[q]),2)  in
      let contrib=new_ev*orientation_nr_term(ori_nr_p,q)*full_deform(q,delta) in
	 (fixed_terms+:=contrib,
         terms#:=("fixed",ev,q,contrib))
    else
         let contrib=ev*orientation_nr_term(ori_nr_p,q)*one_plus_s*(q*0) in
	 (unfixed_terms+:=contrib,
         terms#:=("unfixed",ev,q,contrib))
    fi)
  od
; (character_formula,terms,fixed_terms + divide_by(2,unfixed_terms))
)

{if delta isn't given assume it is the default}
set c_form_irreducible_twisted_long (Param p) =(ParamPol,[(string,Split,Param,ParamPol)],ParamPol):
c_form_irreducible_twisted_long(p,real_form(p).distinguished_involution)

{for backwards compability:}
set c_form_irreducible_delta_long (Param p) =(ParamPol,[(string,Split,Param,ParamPol)],ParamPol):
c_form_irreducible_twisted_long(p)

{print versions}
set print_c_form_irreducible_twisted_long (Param p) = void:
( let formula=c_form_irr_as_sum_of_standards(p,delta) then
  ()=prints(new_line,new_line,"Form on irreducible in terms of standards:", formula) then
  (,b,f) = c_form_irreducible_twisted_long(p) in		  
  for (type,coeff,q,Q) in b
  do prints("")
  ; prints("standard module: ",q)
  ; prints("coeff*form on standard: ")
  ; pol_format(Q)
  od
; prints(""); prints("c-form on irreducible module:")
; prints(p, " at ",infinitesimal_character(p)); pol_format(f)
)

{ analyse }

{ print only terms with "mixed" coefficient (a+bs), i.e., both a,b\ne 0 }
set mixed (Split w)= bool: let (a,b)=%w in a*b!=0
set analyse (ParamPol P) = void:
( prints("Mixed terms:")
; for w@p in P
  do
    if mixed(w)
    then prints("(",split_format(w),")*",p,", ",infinitesimal_character(p))
    fi
  od
)


{ ---------------------------------------- }

{ commands for converting from c-form to hermitian-form}
{ Compute (lambda+rho) restricted to torus T }

{ lambda\in X^*+rho =>
    one can define a parameter with this lambda, as p=param(x,lambda-rho,0)
  then infinitesimal_character(p)=(1+theta)lambda/2
  which is lambda restricted to T-tilde
  apply this with lambda-rho=0, returns (1+theta)rho/2     (on T-tilde)
  apply this with lambda-rho,   return  (1+theta)lambda/2  (on T-tilde)
  then the sum is (1+theta)(lambda+rho)/2 on T
}
set lambda_plus_rho_res_T(KGBElt x,ratvec lambda) = ratvec:
  (1+involution(x))*(lambda+rho(real_form(x)))/2

{ mu(p) is the value of the lowest K-type of p, evaluated at x(p) }
{ formula: < (1+theta_x)(lambda+rho)/2 , torus_factor(x)+rho^\vee > }
set mu(Param p) = rat:
  lambda_plus_rho_res_T(x(p),lambda(p))*
  (torus_factor(x(p))+rho_check(real_form(p)))

set convert_cform_hermitian (ParamPol P)= ParamPol:
  if #P=0 then P { since we cannot select a term for a null polynomial }
  else
    let a_mu = mu(first_param(P))
    in null_module(real_form(P)) +
      for w@p in P do (s^(rat_as_int(mu(p)-a_mu))*w,p) od
  fi

{  converting to Hermitian forms in unequal rank case  }

{assumption: theta_x commutes with delta
=> positive real roots are delta-invariant
also no C- roots (this holds if x=x(p) from (finalized) parameter with nu=0)
need number of pairs {alpha,delta(alpha)} for which alpha is positive real
and <alpha,delta(alpha^vee)>=0
this computes the sign of delta acting on Lambda^top(positive real roots)
each orthgonal pair {alpha,delta(alpha)} contributes -1
if <alpha,delta(alpha)>=-1 this contribute 1 by computation in SL(3,R)
 -1 from pair is cancelled by -1 from action on [X_alpha,X_delta(alpha)=X_{alpha+beta}
if delta(alpha)=alpha contributes 1 by reduction to simple case,
note every real-simple root is simple
}
set number_real_orthogonal_pairs(KGBElt x, mat delta)=
let rd=root_datum(x) then
theta=involution(x) in
assert(delta*theta=theta*delta,"Cartan involution does not commute with delta");
assert(no_Cminus_roots(x), "Not defined unless all complex roots are type C+");
let real_roots=real_posroots(rd,theta) then
pairs=[] in
for alpha in real_roots do
 let pairing=delta*alpha*coroot(rd,alpha) in
   assert(pairing=0 or pairing=-1 or pairing=2
         ,"invalid pairing of root and coroot");
   if pairing=0 then pairs#:=alpha fi
  od;rat_as_int(#pairs/2)

{implementing formula from Vogan in email 10/25/16, subject line mu(p)}
set mu(Param p,mat delta)=rat:
assert(nu(p)=null(rank(root_datum(p))),"nu(p) !=0");
let (ic,delta,gamma,lambda,theta,g,l,omega,tau,t)=E(delta,p) then
lambda_rho_term=lambda*(g-l) then
tau_term=(tau*(^delta-1)*l)/2 then
dim_term=dim_u_cap_p(x(p)) then
scalar_term=number_real_orthogonal_pairs(x(p),delta)  then
new_term=2*rho_r(x(p))*(g-l) in
{prints("lambda_rho_term:", lambda_rho_term,new_line,"tau_term=",tau_term,new_line
      ,"dim_term=", dim_term,new_line,"scalar_term=",scalar_term, new_line,"new_term:", new_term);}
lambda_rho_term+ tau_term+dim_term+scalar_term+new_term

{remaining terms copied over from corresponding versions in hermitian.at}
set convert_cform_hermitian (ParamPol P,mat delta)= ParamPol:
  if #P=0 then P { since we cannot select a term for a null polynomial }
  else
    let a_mu = mu(first_param(P),delta)
    in null_module(real_form(P)) +
      for w@p in P do (s^(rat_as_int(mu(p,delta)-a_mu))*w,p) od
  fi

{   Hermitian forms on irreducibles     }

{ ParamPol giving the hermitian form on irreducible p in all cases}
set hermitian_form_irreducible(Param p) = ParamPol:
if is_equal_rank(real_form(p)) then
   convert_cform_hermitian(c_form_irreducible(p))
else
   convert_cform_hermitian(c_form_irreducible_twisted(p),real_form(p).distinguished_involution) fi

{ ParamPol giving the hermitian form on irreducible p in all cases}
set hermitian_form_irreducible_debug(Param p) = ParamPol:
if is_equal_rank(real_form(p)) then
   convert_cform_hermitian(c_form_irreducible(p))
else
   let cf=c_form_irreducible_twisted(p,real_form(p).distinguished_involution)  then
   mu_0=mu(first_param(cf)) in
   let ()=prints("mu_0=", mu_0) in 
   for c@p in cf do 
let (ic,delta,gamma,lambda,theta,g,l,omega,tau,t)=E(real_form(p).distinguished_involution,p) then
lambda_rho_term=lambda*(g-l) then
tau_term=(tau*(^delta-1)*l)/2 then
dim_term=dim_u_cap_p(x(p)) then
scalar_term=number_real_orthogonal_pairs(x(p),delta)  then
new_term=2*rho_r(x(p))*(g-l) then 
mu=lambda_rho_term+tau_term+dim_term+scalar_term+new_term in
prints(p, "    ", c , "     ", "  ", lambda_rho_term, "  ", tau_term, "     ", dim_term, "     ", scalar_term, "     ", new_term, "   ", mu, "  ", c*s^(rat_as_int(mu-mu_0))) od
;convert_cform_hermitian(cf) fi




{ nice output of hermitian_form_irreducible }
set print_hermitian_form_irreducible(Param p,mat delta) = void:
  pol_format(hermitian_form_irreducible(p))

{ nice output of Hermitian forms on list of parameters }
set print_hermitian_form_irreducible([Param] P,mat delta) = void:
  for p in P
  do prints("");prints("Hermitian form on irreducible: ",p)
  ; print_hermitian_form_irreducible(p,delta)
  od

{ nice output of hermitian_form_irreducible }
set print_hermitian_form_irreducible(Param p) = void:
  pol_format(hermitian_form_irreducible(p))

{ nice output of Hermitian forms on list of parameters }
set print_hermitian_form_irreducible([Param] P) = void:
  for p in P
  do prints("");prints("Hermitian form on irreducible: ",p)
  ; print_hermitian_form_irreducible(p)
  od

{   unitarity and weak unitarity tests }

{ assuming P is the ParamPol of the Hermitian
  form on an irreducible, is_unitary(P) tests
  if it is unitary: <=> every Split coefficient is real, or every Split coefficient is nonreal
}
set is_unitary(ParamPol P)= bool:is_pure(P)  {see basic.at}

{ compute Hermitian form on p, and report if it is unitary }
set is_unitary (Param p) = bool: is_unitary(hermitian_form_irreducible(p))

set print_is_unitary(Param p)=void:
let P=hermitian_form_irreducible(p) in
if is_unitary(P) then prints("Unitary") else
let (real,nonreal,mixed)=purity(P) in
prints("Non-Unitary",new_line, real, " real terms", new_line, nonreal," nonreal terms", new_line, mixed, " mixed terms") fi

{no mixed terms}
set is_weakly_unitary(ParamPol P)= bool:
let (,,mixed)=purity(P) in mixed=0

{ compute Hermitian form on p, and report if it is weakly unitary,
i.e. no mixed terms
}
set is_weakly_unitary (Param p) = bool:
let G=real_form(p) in
if is_equal_rank(G) then is_weakly_unitary(c_form_irreducible(p)) else is_weakly_unitary(c_form_irreducible_delta(p)) fi

{  "big" versions: see extParamPol.at }

set test_line (Param p) = void:
( let (x,lambda_minus_rho,gamma) = %p
  then points=reducibility_points(p)
  ,   ipoints=integrality_points(root_datum(p),2*nu(p))
  in prints("testing line through ", p)
; prints("reducibility points: ",points)
; prints("integrality points (for 2*nu): ",ipoints)
; if #points=0
  then prints("entire line is irreducible and unitary"
       	     ,if is_final(p*0) then "" else " (nu=0 is not final)" fi)
  else points:=(0/1)#points { tack on initial zero }
  ; if not points[#points-1]=1/1 then points:=points#(1/1) fi
  ; for i:#points-1 from 1
    do
      let t=(points[i]+points[i-1])/2
      then q=param(x,lambda_minus_rho,gamma*t)         { mid point interval }
      ,    r=param(x,lambda_minus_rho,gamma*points[i]) { end point interval }
      in prints(nu(p)*t,": ", is_unitary(q))
      ;  prints(nu(p)*points[i],": ", is_unitary(r))
    od
  fi
)


set weak_test(Param p)=bool:
let formula=c_form_irreducible_delta(p) then
bad=null_module(real_form(p)) in
for w@p in formula do
 if not is_pure(w) then bad+:=w*p fi od;
if #bad=0 then prints("number of terms: ", #formula);true else
prints("number of terms: ", #formula,new_line,"bad terms:", bad );false fi

set strong_test(Param p,mat delta)=bool:
let formula=hermitian_form_irreducible(p) then
bad=null_module(real_form(p)) in
for w@p in formula do
 if not is_pure(w) then bad+:=w*p fi od;
if #bad=0 then prints("number of terms: ", #formula);true else
prints("number of terms: ", #formula,new_line,"bad terms:", bad );false fi

