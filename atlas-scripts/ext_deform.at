<basic.at
<extended.at
<extended_misc.at { for |fixed_block| }
<polynomial.at
<dual.at { for |length_diff| }

set ext_KL_block (Param p, mat delta) = { emulate built-in KL_block }
    ([Param],int,mat,[vec],vec,vec,mat):
  let (regular_extblock,,,) = extended_block(p,delta)
  , (KL_mat,polys,stops) = raw_ext_KL(p,delta)
  , survivors = vec: []
  then columns = [vec]:
    for q@j in regular_extblock
    do let Q = finalize_extended(q,delta) in
      if Q[q]=1 then survivors #:= j fi { gather those expanding to themselves }
    ; vec: for i in regular_extblock do Q[i].s_to_minus_1 od
    od
  , reg_size = #regular_extblock
  in (regular_extblock, first(reg_size,(int i):regular_extblock[i]=p)
     ,KL_mat,polys,stops
     ,survivors
     ,matrix((#survivors,reg_size) { slice out the surviving rows: }
            ,(int i,int j) int: columns[j][survivors[i]]
            )
     )

set cook_KL_block ([Param] B,int entry_elem
                  ,mat KL,[poly] polys,vec stops
                  ,vec surv, mat contrib) = ([Param],int,poly_mat,vec):
  let nB=#B, n_surv=#surv
  then raw_P_mat = poly_mat: { survivor columns extracted and transposed }
    for j in surv do let KL_j=KL[j] in
      for i:nB do
        let ind=KL_j[i] in if ind<0 then -polys[-ind] else polys[ind] fi
      od
    od
  then cooked_P_mat = poly_mat:
     for i:n_surv do for j:n_surv do
       let raw_col_j = raw_P_mat[j], sum=poly_0 in
       for k:nB do sum+:=contrib[i,k]*raw_col_j[k] od; sum
     od od
  , get_index (int z) = int: { least |i| with |surv[i]>=z| }
    let min=0, max=n_surv in
    while min<max
    do let avg=(min+max)\2 in if surv[avg]>=z then max:=avg else min:=avg+1 fi
    od; min
  in ( for i in surv do B[i] od
     , get_index(entry_elem)
     , cooked_P_mat
     , for s in stops do get_index(s) od
     )

set ed_verbose=false
set ed_verbose2=false

set null_wt(int r) = ratvec: null(r)
set has_nu0 (Param p) = bool: =nu(p)

{ Compute the direct (P) extended Kazhdan-Lusztig-Vogan polynomials
  |B_fixed| should be the delta-fixed parameters in a block
  The result is a row-gathered matrix of (univariate) polynomials
}

set KL_P_polynomials_1 ([Param] B_fixed,mat delta) = [[poly]]:
  assert( all(for p in B_fixed do is_fixed(delta,p) od)
  	, "Not every parameter is delta-fixed" );
  let (P,polys,)=raw_ext_KL(B_fixed[0],delta) in
  for row@i in ^P
  do
    for entry@j in row
    do {(-1)^length_diff(i,j,jumps)
     *} if >=entry then polys[entry] else -polys[-entry] fi
    od
  od

set KL_P_signed_polynomials_1 ([Param] B_fixed,mat delta) = [[poly]]:
  assert( all(for p in B_fixed do is_fixed(delta,p) od)
	, "Not every parameter is delta-fixed" );
  let (P,polys,jumps)=raw_ext_KL(B_fixed[0],delta) in
  for row@i in ^P
  do
    for entry@j in row
    do (-1)^length_diff(i,j,jumps)
     * if >=entry then polys[entry] else -polys[-entry] fi
    od
  od

set KL_Q_polynomials ([Param] B_fixed, mat delta) = [[poly]]:
  upper_unitriangular_inverse (KL_P_signed_polynomials_1(B_fixed,delta))

set deform (Param p, mat delta) = ParamPol:
( assert(is_fixed(delta,p),"parameter is not delta-fixed");
  let (B_f,index) = fixed_block(delta,p) { hopefully the same block as KL_P }
  , l_index=length(p) { use built-in function |length| for Param |p| }
  then P_signed_polys=KL_P_signed_polynomials_1(B_f,delta)
  then Q_polys=upper_unitriangular_inverse(P_signed_polys)
  in
  if ed_verbose then prints("index=",index) fi;
  let outer_sum = null_module(real_form(p))
  + for p_i@i in B_f[:index] { traverse |B_f| up to the index of |p| }
    do
      if ed_verbose then prints("outer loop i=",i) fi;
      let l_i=length(p_i), P_signed_i=P_signed_polys[i]
      , onr=(-1)^rat_as_int((orientation_nr(p)-orientation_nr(p_i))/2)
      , inner_sum=0 in
      if ed_verbose then prints("onr=", onr)  fi;
      for p_j@j_minus_i in B_f[i:index]
      do
        let j=j_minus_i+i, l_j=length(p_j) in
        if ed_verbose
        then prints("  inner loop j=",j)
        ;    prints("  length_diff:", l_index-l_j)
        fi;
        if is_odd(l_index-l_j)
        then
          let P_ij= poly: P_signed_i[j]
          , Q_jindex= poly: Q_polys[j][index]
	  then term= eval(P_ij,-1) * eval(Q_jindex,-1)
          in
          if ed_verbose then prints("   inner term: ", term) fi
	; inner_sum+:=term
        ; if ed_verbose then prints(" inner_sum is now:", inner_sum) fi
        fi
      od
    ; let contrib = (Split,Param):
        (onr*inner_sum {coefficient}, B_f[i] {monomial})
      in
      if ed_verbose
      then prints("onr=",onr,new_line
		 ,"inner_sum=",inner_sum,new_line
		 ,"contribution with i=", i, ":", contrib)
      fi
    ; contrib
    od
    in (1-s)*outer_sum
)

set rec_def (Param p,mat delta) = (Param,ParamPol):
  if ed_verbose2 then prints("rec_def with:", p) fi;
  if is_zero(p) or not is_final(p) or not is_fixed(delta,p)
  then error("improper parameter")
  fi;
  let !empty=null_module(real_form(p))
  then rec_fun recd (Split coef,Param p) = (Param,ParamPol):
     { |coef| to be multiplied to deformation terms }
    begin
    if ed_verbose2 then prints("recd with:", p) fi;
    if has_nu0(p) then (p,empty) { but deformed |p| has |coef| implicitly }
    elif not is_standard(p) then prints(p,%p); error("halt")
    else
      let (x,lambda,gamma)=%p, rp=reducibility_points(p)
      then inx=#rp, at_nu0=empty, acc=empty
      in
      while inx>0
      do
        let p_def=param(x,lambda,gamma*rp[inx-:=1]) in
        let def=deform(p_def,delta) in
	if ed_verbose2
        then prints("adding deformation term: p=", p_def, new_line
	           , "adding:", def)
	fi;
	acc+:=def
      od
    ; for k@q in acc
      do
        let c=coef*k then (q0,nu0_terms) = recd(c,q)
	in at_nu0 +:= nu0_terms+(c,q0)
      od
    ; { return deformed p and accumulated deformation terms }
      (param(x,lambda,null_wt(#gamma)), at_nu0)
    fi
    end
  in recd(1,p)

{ alternative, use the new built-in |extended_KL_block| }
set deformation_terms (Param p, mat delta) = ParamPol:
  assert(is_fixed(delta,p),"parameter is not delta-fixed");
  let (B,P_mat,length) = extended_KL_block(p,delta) then nB=#B in
  if =nB or B~[0]!=p
  then null_module(p) { if |p| itself is not among survivors, return 0 }
  else { compute final column |acc| of |Q| matrix by solving linear system
         $P'*acc=e_p$ with $P'$ a matrix of Split, columns from |KL_sum_at_s| }
    let remainder = null(nB-1)#1 { start with standard basis vector for |p| }
    , solution=null(nB)
    , !opposite_parity=1-length~[0]%2 { opposite to that of |length(p)| }
    , !on_p = orientation_nr(p)
    in
    for q_ind : nB
    ~do let contrib=remainder[q_ind]*P_mat[q_ind] in
      remainder -:= contrib
    ; if length[q_ind]%2=opposite_parity
      then solution +:= contrib
      fi
    od
  ; null_module(p)+
    for c@i in solution
    do { twist (1-s)*solution according to orientation numbers of its terms }
      let x=B[i] then (q,r)=(on_p-orientation_nr(x))\%2 in
      assert(=r,"odd orientation");
      (minus_1^q*c*one_minus_s,x) { we have |s^q*c*(1-s) = (-1)^q*c(1-s)| }
      { for the same reason we replaced |s| by |-1| in computations giving |c| }
    od
  fi

set recursive_deform (Param p, mat delta) = ParamPol:
  assert(not is_zero(p) and is_final(p) and is_fixed(delta,p)
	,"improper parameter");
  let empty=null_module(real_form(p)) in
  if ed_verbose { choose verbose or non-verbose version of the function }
  then rec_fun full_def (Split sc,Param p) ParamPol:
       { |sc| will simply scale the resulting ParamPol, |delta| is implicit }
    begin
      prints("full_def with: sc=", sc, ", p=", p);
      assert(is_standard(p)
	    ,"non standard parameter encountered in deformation");
      let acc=empty, at_nu0=ParamPol: sc*(p*0) { fully deformed |p| } in
      for factor in reducibility_points(p)
      ~do
	let p_def=p*factor { next deformation of |p| }
	then def=deformation_terms(p_def,delta)
	in
	prints("adding deformation term: p=", p_def, new_line,"adding:", def)
      ; acc+:=def
      od
    ; for k@q in acc { traverse the sum of the deformation terms spun off }
      do { apply |full_def| recursively to all those terms }
        at_nu0 +:= full_def(sc*k,q) { gather harvest from those deformations }
      od
    ; at_nu0
    end
  else rec_fun full_def (Split sc,Param p) ParamPol:
       { |sc| will simply scale the resulting ParamPol, |delta| is implicit }
    begin
      assert(is_standard(p),"non standard parameter in deformation");
      let acc=empty, at_nu0=ParamPol: sc*(p*0) { fully deformed |p| } in
      for factor in reducibility_points(p)
      ~ { direction of deformation is down, towards 0; this is not essential }
      do acc+:=deformation_terms(p*factor,delta) od
    ; for k@q in acc { traverse the sum of the deformation terms spun off }
      do at_nu0 +:= full_def(sc*k,q) od
    ; at_nu0
    end
  fi { apply that recursive function to the initial argument: } (1,p)

set full_deform = recursive_deform@(Param,mat)
{ used to be: (Param p,mat delta) ParamPol: let (a,P)=rec_def(p,delta) in a+P }

set c_form_std (Param p,mat delta) = ParamPol:
  let G=real_form(p) in
  if is_equal_rank(G) then full_deform(p) { buiit in }
  else full_deform(p,delta) { defined above }
  fi
